However, checked exceptions can either require extensive throws declarations, revealing implementation details and reducing encapsulation, or encourage coding poorly considered try/catch blocks that can hide legitimate exceptions from their appropriate handlers.[citation needed] Consider a growing codebase over time. An interface may be declared to throw exceptions X and Y. In a later version of the code, if one wants to throw exception Z, it would make the new code incompatible with the earlier uses. Furthermore, with the adapter pattern, in which one body of code declares an interface that is then implemented by a different body of code so that code can be plugged in and called by the first, the adapter code may have a rich set of exceptions to describe problems, but is forced to use the exception types declared in the interface.