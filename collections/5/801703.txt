However, in addition to several other disadvantages, since the default arguments are not modeled in the type system, the type of a callback (aka higher-order function) can’t express that it accepts either of the overloads nor simulate the default arguments with overloaded functions. Whereas, in JavaScript the non-overloaded function definition can substitute the default when the input value is undefined (regardless if it was implicitly undefined via the argument’s absence at the call site or an explicitly passed undefined value); which is modeled as an optional argument parameter type ?: in TypeScript. JavaScript’s solution is not resolved statically (i.e. not at compile-time, which is why TypeScript models only the optionality and not the default values in the function’s type signature) thus incurs additional runtime overhead, although it does provide more flexibility in that callbacks can independently control their defaults instead of centrally dictated by the (callback’s type signature in the) type signature of the function which inputs the callback. The TypeScript solution can be simulated in Java with the Optional type except the analogous of an implicit undefined for each absent argument is an explicit Optional.<Integer>absent() at the call site.