The lambda calculus may be seen as an idealised version of a functional programming language, like Haskell or Standard ML. Under this view, beta reduction corresponds to a computational step. This step can be repeated by additional beta conversions until there are no more applications left to reduce. In the untyped lambda calculus, as presented here, this reduction process may not terminate. For instance, consider the term     Ω = ( λ x . x x ) ( λ x . x x )   {\displaystyle \Omega =(\lambda x.xx)(\lambda x.xx)}  . Here     ( λ x . x x ) ( λ x . x x ) → ( x x ) [ x := λ x . x x ] = ( x [ x := λ x . x x ] ) ( x [ x := λ x . x x ] ) = ( λ x . x x ) ( λ x . x x )   {\displaystyle (\lambda x.xx)(\lambda x.xx)\to (xx)[x:=\lambda x.xx]=(x[x:=\lambda x.xx])(x[x:=\lambda x.xx])=(\lambda x.xx)(\lambda x.xx)}  . That is, the term reduces to itself in a single beta reduction, and therefore the reduction process will never terminate.